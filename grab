#!/usr/bin/env bash

VER="0.4.0"

GR="\033[0;36m"
RD="\033[0;31m"
YL="\033[0;33m"
OF="\033[0m"

function msg {
    echo -e "$GR${1}$OF"
}

function warn {
    echo -e "$YL${1}$OF"
}

function err {
    echo -e "$RD${1}$OF"
}


command -v wget >/dev/null 2>&1 || { err "wget not installed"; exit 1;} 
command -v unzip >/dev/null 2>&1 || { err "unzip not installed"; exit 1;} 
command -v tar >/dev/null 2>&1 || { err "tar not installed"; exit 1;} 
command -v curl >/dev/null 2>&1 || { err "curl not installed"; exit 1;} 

repo="/opt/grab"
indir="/usr/local/bin"

if [[ "${OSTYPE}" == *"solaris"* ]]; then
    indir="/usr/bin"
    grep="/usr/xpg4/bin/grep"
else
    grep="grep"
fi

function banner {

    msg "\nGRAB‚úä version ${VER}"
    msg "platform: ${OSTYPE}"

}

function install {

    banner

    [ -z "$1" ] && { err "1st arggument must be a github address in the format: user/repo"; exit 1; }

    u="${1}"        # url
    p="${1##*/}"    # project name

    if [ -z "$2" ]; then
        ex=${1##*/}
        warn "2rd arggument (executable name) missing, assuming it is: ${ex}"
        e="${ex}"
    else
        e="${2}"
    fi

    # grab list of released files from github
    lst=$(curl -s "https://api.github.com/repos/${u}/releases/latest" \
        | grep "browser_download_url" | cut -d '"' -f 4 | xargs -n1 basename \
        | grep "${p}" | $grep -E 'zip$|gz$') \
        || { err "unable to find eligible files in the latest release of this repository"; exit 1; }

    echo -e "\nüëâ Choose the version you would like to install:\n"
    select choice in ${lst}; do
        if [[ -n $choice ]]; then
            a="${choice}"
            msg "\nYou chose to install ${a}"
            break
        else
            err "Invalid choice, try again"
        fi
    done


    tmpf="/tmp/grab_cache_$$"
    msg "Creating cache in ${tmpf}"
    mkdir "${tmpf}"

    [ -d "${tmpf}" ] || { err "failed to create cache folder ${tmpf}"; exit 1; }

    cd ${tmpf} || { err "could not switch to cache folder ${tmpf}"; exit; }

    msg "Downloading ${a} from github.com/${u}" 
    wget -qN "https://github.com/${u}/releases/latest/download/${a}" || { err "Unable to download https://github.com/${u}/releases/latest/download/${a}"; exit 1; }

    [ -f "${a}" ] || { err "File ${a} not found in ${tmpf}"; cd /tmp; rm -rf ${tmpf}; exit 1; }

    ext="${a##*.}"
    msg "Archive type is ${ext}"

    od="${tmpf}/out"
    msg "Extracting ${e} from ${a} into ${od}"

    if [ "$ext" == "zip" ]; then
        unzip -oq "${a}" -d ${od}
        [ -f ${od}/"${e}" ] || { ls -lh ${od}; warn "Unable to find ${e}, flattening..."; rm -rf ${od}; mkdir -p ${od}; unzip -oqj "${a}" -d ${od}; }
        [ -f ${od}/"${e}" ] || { ls -lh ${od}; err "Unable to find ${e}, giving up."; cd /tmp; rm -rf ${tmpf}; exit 1; }
    elif [ "$ext" == "gz" ]; then
        mkdir -p ${od}
        [ -d ${od} ] || { err "Failed to create output directory ${od}"; cd /tmp; rm -rf ${tmpf}; exit 1; }
        cp "${a}" "${od}/"
        [ -f "${od}/${a}" ] || { err "Failed to copy ${a} to ${od}"; cd /tmp; rm -rf ${tmpf}; exit 1; }
        cd ${od} || { err "Could not switch to output directory ${od}"; cd /tmp; rm -rf ${tmpf}; exit 1; }
        tar -xzf "${a}"
        [ -f ${od}/"${e}" ] || { ls -lh ${od}; warn "Unable to find ${od}/${e}, flattening 1 level..."; rm -rf ${od}; mkdir -p ${od}; tar -xzf "${a}" --strip-components 1 -C ${od}; }
        [ -f ${od}/"${e}" ] || { ls -lh ${od}; warn "Unable to find ${od}/${e}, flattening 2 levels..."; rm -rf ${od}; mkdir -p ${od}; tar -xzf "${a}" --strip-components 2 -C ${od}; }
        [ -f ${od}/"${e}" ] || { ls -lh ${od}; warn "Unable to find ${od}/${e}, flattening 3 levels..."; rm -rf ${od}; mkdir -p ${od};  tar -xzf "${a}" --strip-components 3 -C ${od}; }
        [ -f ${od}/"${e}" ] || { ls -lh ${od}; err "Unable to find ${od}/${e}, giving up."; cd /tmp; rm -rf ${tmpf}; exit 1; }
    else
        err "Unable to extract from ${ext}"
        cd /tmp
        rm -rf ${tmpf}
    fi

    [ -f ${od}/"${e}" ] || { err "Unable to unzip ${a}"; cd /tmp; rm -rf ${tmpf}; exit 1; }

    msg "Making ${e} executable..."
    chmod +x ${od}/"${e}" || { err "Unable to make ${e} executable"; cd /tmp; rm -rf ${tmpf}; exit 1; }

    msg "Installing ${e} to ${repo}..."
    sudo mv ${od}/"${e}" "${repo}/" || { err "failed to move ${e} to ${repo}"; cd /tmp; rm -rf ${tmpf}; exit 1; }

    [ -f ${repo}/"${e}" ] || { err "failed to install ${e}"; cd /tmp; rm -rf ${tmpf}; exit 1; }

    msg "\nLinking to ${indir}/${e}..."
    sudo ln -sf "${repo}/${e}" "${indir}/${e}" || { err "failed to link ${e} to ${indir}"; cd /tmp; rm -rf ${tmpf}; exit 1; }

    [ -f "${indir}/${e}" ] || { err "failed to create symlink in ${indir}"; cd /tmp; rm -rf ${tmpf}; exit 1; }

    msg "Successfully installed!\n"

    warn "To uninstall: grab -r ${e}"

    msg "\nDeleting ${tmpf} and cleaning up..."
    cd /tmp
    rm -rf ${tmpf}

    [ -d "${tmpf}" ] && { err "Failed to delete cache folder ${tmpf}"; exit 1; }

    msg "done üëç\n"

}

function remove {
    banner

    [ -z "$1" ] && { err "1st arggument must be the name of the executable to remove"; exit 1; }

    e="${1}"


    # make sure /opt/grab/<e> exists and that <indir>/<e> is a symlink to it
    if [ -f "${repo}/${e}" ] && [ -L "${indir}/${e}" ] && [ "$(readlink "${indir}/${e}")" == "${repo}/${e}" ]; then

        msg "\nRemoving ${repo}/${e}..."
        sudo rm -f "${repo}/${e}" || { err "failed to remove ${repo}/${e}"; exit 1; }
        
        if [ -L "${indir}/${e}" ]; then
            msg "Removing symlink ${indir}/${e}..."
            sudo rm -f "${indir}/${e}" || {  err "failed to remove symlink ${indir}/${e}"; exit 1; }
        else
            err "symlink ${indir}/${e} not found"
            warn "program may not have been properly linked during installation"
            exit 1;
        fi

    else
        err "${repo}/${e} not found..."
        warn "${e} may not have been installed by grab, try removing manually"
        exit 1
    fi


    msg "\nSuccessfully uninstalled ${e}!\n"
    msg "done üëç\n"

}


function firstrun {
    msg "It looks like you are running grab for the first time..."
    warn "Creating installation directory at ${repo}..."
    sudo mkdir -p "${repo}" || { err "failed to create ${repo}"; exit 1; }
}

[ -d "${repo}" ] || firstrun


if [ "$1" == "-v" ] || [ "$1" == "--version" ]; then
    echo "${VER}"
    exit 0
fi

if [ -z "$1" ] || [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    banner
    echo -e "\nUsage: grab <github_user/repo> [executable_name]\n"
    echo -e "Example: burntsushi/ripgrep rg\n"
    echo -e "This will install the latest release of rg from the repository\n"
    echo -e "Positional arguments:\n"
    echo -e "  github_user/repo     GitHub repository in the format user/repo\n"
    echo -e "  executable_name      (optional) Name of the executable to install\n"
    exit 0
fi

# if the first argument is -l or --list, list installed executables

if [ "$1" == "-l" ] || [ "$1" == "--list" ]; then
    banner
    msg "\nInstalled executables in ${repo}:\n"
    ls -1 "${repo}"

    msg "\nTo uninstall an executable, use: grab -r <executable_name>\n"
    exit 0
fi

if [ "$1" == "-r" ] || [ "$1" == "--remove" ]; then
    if [ -z "$2" ]; then
        err "2nd argument must be the name of the executable to remove"
        exit 1
    fi
    remove "$2"
    exit 0
fi

install "$1" "$2"


