#!/usr/bin/env bash

VER="0.4.4"

GR="\033[0;36m"
RD="\033[0;31m"
YL="\033[0;33m"
OF="\033[0m"

function msg {
    echo -e "$GR${1}$OF"
}

function warn {
    echo -e "$YL${1}$OF"
}

function err {
    echo -e "$RD${1}$OF"
}


command -v wget >/dev/null 2>&1 || { err "wget not installed"; exit 1;} 
command -v unzip >/dev/null 2>&1 || { err "unzip not installed"; exit 1;} 
command -v tar >/dev/null 2>&1 || { err "tar not installed"; exit 1;} 
command -v curl >/dev/null 2>&1 || { err "curl not installed"; exit 1;} 

repo="/opt/grab"
indir="/usr/local/bin"

if [[ "${OSTYPE}" == *"solaris"* ]]; then
    indir="/usr/bin"
    grep="/usr/xpg4/bin/grep"
else
    grep="grep"
fi

function banner {

    msg "\nGRAB ‚úä version ${VER}"
    msg "platform: ${OSTYPE}"

}

function install {

    banner

    [ -z "$1" ] && { err "1st arggument must be a github address in the format: user/repo"; exit 1; }

    u="${1}"        # url
    p="${1##*/}"    # project name

    if [ -z "$2" ]; then
        ex=${1##*/}
        warn "2rd arggument (executable name) missing, assuming it is: ${ex}"
        e="${ex}"
    else
        e="${2}"
    fi

    # prevent overwriting unmanaged binaries in <indir>
    if [ -f "${indir}/${e}" ] && { [ ! -L "${indir}/${e}" ] || [ "$(readlink "${indir}/${e}")" != "${repo}/${e}" ]; }; then
        err "File ${indir}/${e} already exists and is not a symlink to ${repo}/${e}"
        warn "Please remove or rename ${indir}/${e} before proceeding"
        exit 1
    fi

    # grab list of released files from github
    lst=$(curl -s "https://api.github.com/repos/${u}/releases/latest" \
        | grep "browser_download_url" | cut -d '"' -f 4 | xargs -n1 basename \
        | grep "${p}" | $grep -E 'zip$|gz$') \
        || { err "unable to find eligible files in the latest release of this repository"; exit 1; }

    echo -e "\nüëâ Choose the version you would like to install:\n"
    select choice in ${lst}; do
        if [[ -n $choice ]]; then
            a="${choice}"
            msg "\nYou chose to install ${a}"
            break
        else
            err "Invalid choice, try again"
        fi
    done


    tmpf="/tmp/grab_cache_$$"
    msg "Creating cache in ${tmpf}"
    mkdir "${tmpf}"

    [ -d "${tmpf}" ] || { err "failed to create cache folder ${tmpf}"; exit 1; }

    cd ${tmpf} || { err "could not switch to cache folder ${tmpf}"; exit; }

    msg "Downloading ${a} from github.com/${u}" 
    wget -qN "https://github.com/${u}/releases/latest/download/${a}" || { err "Unable to download https://github.com/${u}/releases/latest/download/${a}"; exit 1; }

    [ -f "${a}" ] || { err "File ${a} not found in ${tmpf}"; cd /tmp; rm -rf ${tmpf}; exit 1; }

    ext="${a##*.}"
    msg "Archive type is ${ext}"

    od="${tmpf}/out"
    msg "Extracting ${e} from ${a} into ${od}"

    if [ "$ext" == "zip" ]; then

        unzip -oq "${a}" -d ${od}
        [ -f ${od}/"${e}" ] || { ls -lh ${od}; warn "Unable to find ${e}, flattening..."; rm -rf ${od}; mkdir -p ${od}; unzip -oqj "${a}" -d ${od}; }
        [ -f ${od}/"${e}" ] || { ls -lh ${od}; err "Unable to find ${e}, giving up."; cd /tmp; rm -rf ${tmpf}; exit 1; }

    elif [ "$ext" == "gz" ]; then

        mkdir -p ${od}
        [ -d ${od} ] || { err "Failed to create output directory ${od}"; cd /tmp; rm -rf ${tmpf}; exit 1; }

        cp "${a}" "${od}/"
        [ -f "${od}/${a}" ] || { err "Failed to copy ${a} to ${od}"; cd /tmp; rm -rf ${tmpf}; exit 1; }

        cd ${od} || { err "Could not switch to output directory ${od}"; cd /tmp; rm -rf ${tmpf}; exit 1; }
        tar -xzf "${a}"

        if [ ! -f "${e}" ]; then
            warn "Unable to find ${e}, searching in subdirectories..."
            etmp=$(find . -type f -name "${e}" | head -n 1 | sed 's|^\./||')
            [ -z "${etmp}" ] && { ls -lh; err "Unable to find ${e}, giving up."; cd /tmp; rm -rf ${tmpf}; exit 1; }
            cp "${etmp}" "${od}/"
            [ -f "${od}/${e}" ] || { err "Unable to copy ${etmp} to ${od}/${e}"; cd /tmp; rm -rf ${tmpf}; exit 1; } 
        fi
    else
        err "Unable to extract from ${ext}"
        cd /tmp
        rm -rf ${tmpf}
    fi

    [ -f ${od}/"${e}" ] || { err "Unable to extract ${a}"; cd /tmp; rm -rf ${tmpf}; exit 1; }

    msg "Making ${e} executable..."
    chmod +x ${od}/"${e}" || { err "Unable to make ${e} executable"; cd /tmp; rm -rf ${tmpf}; exit 1; }

    msg "Installing ${e} to ${repo}..."
    sudo mv ${od}/"${e}" "${repo}/" || { err "failed to move ${e} to ${repo}"; cd /tmp; rm -rf ${tmpf}; exit 1; }

    [ -f ${repo}/"${e}" ] || { err "failed to install ${e}"; cd /tmp; rm -rf ${tmpf}; exit 1; }

    msg "\nLinking to ${indir}/${e}..."
    sudo ln -sf "${repo}/${e}" "${indir}/${e}" || { err "failed to link ${e} to ${indir}"; cd /tmp; rm -rf ${tmpf}; exit 1; }

    [ -f "${indir}/${e}" ] || { err "failed to create symlink in ${indir}"; cd /tmp; rm -rf ${tmpf}; exit 1; }

    msg "Successfully installed!\n"

    warn "To uninstall: grab -r ${e}"

    msg "\nDeleting ${tmpf} and cleaning up..."
    cd /tmp
    rm -rf ${tmpf}

    [ -d "${tmpf}" ] && { err "Failed to delete cache folder ${tmpf}"; exit 1; }

    msg "done üëç\n"

}

function remove {
    banner

    [ -z "$1" ] && { err "1st arggument must be the name of the executable to remove"; exit 1; }

    e="${1}"


    # make sure /opt/grab/<e> exists and that <indir>/<e> is a symlink to it
    if [ -f "${repo}/${e}" ] && [ -L "${indir}/${e}" ] && [ "$(readlink "${indir}/${e}")" == "${repo}/${e}" ]; then

        msg "\nRemoving ${repo}/${e}..."
        sudo rm -f "${repo}/${e}" || { err "failed to remove ${repo}/${e}"; exit 1; }
        
        if [ -L "${indir}/${e}" ]; then
            msg "Removing symlink ${indir}/${e}..."
            sudo rm -f "${indir}/${e}" || {  err "failed to remove symlink ${indir}/${e}"; exit 1; }
        else
            err "symlink ${indir}/${e} not found"
            warn "Program ${e} may not have been properly linked during installation"
            exit 1;
        fi

    else
        err "${repo}/${e} not found..."
        warn "Program ${e} may not have been installed by grab, try removing manually"
        exit 1
    fi


    msg "\nSuccessfully uninstalled ${e}!\n"
    msg "done üëç\n"

}


function firstrun {
    msg "It looks like you are running grab for the first time..."
    warn "Creating installation directory at ${repo}..."
    sudo mkdir -p "${repo}" || { err "failed to create ${repo}"; exit 1; }
}

[ -d "${repo}" ] || firstrun


if [ "$1" == "-v" ] || [ "$1" == "--version" ]; then
    echo "${VER}"
    exit 0
fi

if [ -z "$1" ] || [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    banner

    msg "\nUsage: grab <github_user/repo> [executable_name]\n"
    msg "  <github_user/repo>   : GitHub repository in the format user/repo"
    msg "  [executable_name]    : (optional) name of the executable to install (if different from repo name)"
    msg "\nOptions:"
    msg "  -h, --help           : Display this help message"
    msg "  -v, --version        : Display grab version"
    msg "  -l, --list           : List installed executables"
    msg "  -ls, --list-simple   : Script friendly list (no formatting)"
    msg "  -r, --remove <name>  : Uninstall the specified executable\n"
    msg "Note: options are only allowed as the first argument.\n"
    exit 0
fi


if [ "$1" == "-l" ] || [ "$1" == "--list" ]; then
    banner
    msg "\nInstalled executables in ${repo}:\n"
    ls -1 "${repo}"

    msg "\nTo uninstall an executable, use: grab -r <executable_name>\n"
    exit 0
fi

if [ "$1" == "-ls" ] || [ "$1" == "--list-simple" ]; then
    ls -1 "${repo}"
    exit 0
fi

if [ "$1" == "-r" ] || [ "$1" == "--remove" ]; then
    if [ -z "$2" ]; then
        err "2nd argument must be the name of the executable to remove"
        exit 1
    fi
    remove "$2"
    exit 0
fi

# check that the first argument contains a / character, if not exit with error
if [[ "$1" == *"/"* ]]; then
    install "$1" "$2"
else
    err "1st argument must be a github address in the format: user/repo or an option startng with -"
    exit 1
fi
